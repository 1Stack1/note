# 数据结构

## 简单动态字符串

```Redis自己构建了一种名为简单动态字符串(simple dynamic string, SDS)的抽象类型，并将其作为默认字符串使用```

### SDS定义

```c
struct sdshdr{
    
    //记录buf数组中已经使用的字节的数量
    //等于SDS所保存的字符串的长度
    int len;
    
    //记录buf数组未使用字节的数量
    int free;
    
    //字节数组,用于保存字符串
    char buf[];
}
```

### SDS与C字符转区别

* 常数复杂度获取字符串长度

  ```sdshdr结构体中的len属性```

* 杜绝缓冲区溢出

  ```当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后执行时的修改操作；```

  ```而C字符串容易造成缓冲区溢出，如strcat函数可能修改别的内存空间，造成程序问题```

* 减少修改字符串时带来的内存重分配次数

  ```通过未使用空间来减少内存重分配次数```

  主要有两种优化策略

  - 空间预分配

    ```当SDS的API对一个SDS进行修改并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间```

  - 惰性空间释放

    ```当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用```

* 二进制安全

  ```SDS虽然使用'\0'结尾但是由于有len属性，并会造成二进制安全问题；而C字符串就不能保存像图片、音频、视频这样的二进制数据```

* 兼容部分C字符串函数

  ```SDS和C字符串一样以'\0'结尾```

  

### 重点回顾

- Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。
- 比起 C 字符串， SDS 具有以下优点：
  1. 常数复杂度获取字符串长度。
  2. 杜绝缓冲区溢出。
  3. 减少修改字符串长度时所需的内存重分配次数。
  4. 二进制安全。
  5. 兼容部分 C 字符串函数。

## 链表

链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现，除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表。

### 链表的实现

节点

```c
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

链表

```c
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```

```Redis链表是使用双端链表实现的```

### 重点回顾

- 链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。
- 每个链表节点由一个 `listNode` 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。
- 每个链表使用一个 `list` 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向 `NULL` ， 所以 Redis 的链表实现是无环链表。
- 通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。

## 字典

### 字典的实现

哈希表

```c
typedef struct dictht {

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

} dictht;
```

哈希表节点

```c
typedef struct dictEntry {

    // 键
    void *key;

    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;
```

字典

```c
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;//保存了需要传递给那些类型特定函数的可选参数
    
    //type和privdata属性是针对不同类型的键值对，为创建多态字典而设置的

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

} dict;
```

### 哈希算法

Redis使用的哈希算法

```shell
# 使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);

# 使用哈希表的 sizemask 属性和哈希值，计算出索引值
# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]
index = hash & dict->ht[x].sizemask;
```

### 哈希冲突

Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，因为 `dictEntry` 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f512c5e9256.png)）， 排在其他已有节点的前面。

### rehash

随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：

1. 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0]当前包含的键值对数量 （也即是ht[0].used属性的值）：
   - 如果执行的是扩展操作， 那么 `ht[1]` 的大小为第一个大于等于 `ht[0].used * 2` 的 ![2^n](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f512f991fc2.png) （`2` 的 `n` 次方幂）；
   - 如果执行的是收缩操作， 那么 `ht[1]` 的大小为第一个大于等于 `ht[0].used` 的 ![2^n](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f512f991fc2.png) 。
2. 将保存在ht[0]中的所有键值对 rehash 到ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。
3. 当ht[0] 包含的所有键值对都迁移到了ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。

```复制到新表之后由于hashtable的size改变，sizemask改变，hash值可能改变，索引值可能改变```

### 渐进式rehash

rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的，为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 `ht[0]` 里面的所有键值对全部 rehash 到 `ht[1]` ， 而是分多次、渐进式地将 `ht[0]` 里面的键值对慢慢地 rehash 到 `ht[1]` 。

以下是哈希表渐进式 rehash 的详细步骤：

1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。

```执行渐进式 rehash 的过程中， 字典会同时使用ht[0]和ht[1]两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1]里面， 而ht[0]则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。```

### 重点回顾

- 字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。
- Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。
- 当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。
- 在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。

## 跳跃表

跳跃表是一种可以对有序链表进行近似二分查找的数据结构，redis 在两个地方用到了跳跃表，一个是实现有序集合，另一个是在集群节点中用作内部数据结构。

### 跳跃表的实现

跳跃表节点

```c
typedef struct zskiplistNode {

    // 后退指针
    struct zskiplistNode *backward;//节点的后退指针 ( backward 属性 ) 用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。
    

    // 分值
    double score;//节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。

    // 成员对象
    robj *obj;//节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。

    /*在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：
    分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，
    而成员对象较大的节点则会排在后面(靠近表尾的方向)。*/
    
    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];//每个跳跃表节点的层高都是1到32之间的随机数

} zskiplistNode;
```

跳跃表

```c
typedef struct zskiplist {
    //表头节点和表尾节点
    typedef zskiplistNode *header, *tail;
    
    //表中节点数量
    unsigned long length;
    
    //表中层数最大的节点的层数
    int level;
    
}
```

![image-20230419190927089](redis.assets/image-20230419190927089.png)

### 重点回顾

- 跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。
- Redis 的跳跃表实现由 `zskiplist` 和 `zskiplistNode` 两个结构组成， 其中 `zskiplist` 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 `zskiplistNode` 则用于表示跳跃表节点。
- 每个跳跃表节点的层高都是 `1` 至 `32` 之间的随机数。
- 在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。
- 跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。

## 整数集合

### 整数集合的实现

```c
typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```

`contents` 数组是整数集合的底层实现： 整数集合的每个元素都是 `contents` 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。

### 升级

每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

**升级之后新元素的摆放位置**

因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：

- 在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 `0` ）；
- 在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 `length-1` ）。

**升级的好处**

* 提升灵活性

  因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。

  比如说， 我们一般只使用 `int16_t` 类型的数组来保存 `int16_t` 类型的值， 只使用 `int32_t` 类型的数组来保存 `int32_t` 类型的值， 诸如此类。

  但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 `int16_t` 、 `int32_t` 或者 `int64_t` 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。

* 节约内存

  当然， 要让一个数组可以同时保存 `int16_t` 、 `int32_t` 、 `int64_t` 三种类型的值， 最简单的做法就是直接使用 `int64_t` 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 `int16_t` 类型或者 `int32_t` 类型的值， 数组都需要使用 `int64_t` 类型的空间去保存它们， 从而出现浪费内存的情况。

  而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。

  比如说， 如果我们一直只向整数集合添加 `int16_t` 类型的值， 那么整数集合的底层实现就会一直是 `int16_t` 类型的数组， 只有在我们要将`int32_t` 类型或者 `int64_t` 类型的值添加到集合时， 程序才会对数组进行升级。

**整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。**

### 重点回顾

- 整数集合是集合键的底层实现之一。
- 整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。
- 整数集合只支持升级操作， 不支持降级操作。

## 压缩列表

压缩列表（ziplist）是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。

当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。

压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的**连续内存块**组成的顺序型（sequential）数据结构。

### 压缩列表的构成

一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。

图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。

![image-20230419190945603](redis.assets/image-20230419190945603.png)

------

表 7-1 压缩列表各个组成部分的详细说明

| 属性      | 类型       | 长度     | 用途                                                         |
| :-------- | :--------- | :------- | :----------------------------------------------------------- |
| `zlbytes` | `uint32_t` | `4` 字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 `zlend` 的位置时使用。 |
| `zltail`  | `uint32_t` | `4` 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 |
| `zllen`   | `uint16_t` | `2` 字节 | 记录了压缩列表包含的节点数量： 当这个属性的值小于 `UINT16_MAX` （`65535`）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 `UINT16_MAX` 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| `entryX`  | 列表节点   | 不定     | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。     |
| `zlend`   | `uint8_t`  | `1` 字节 | 特殊值 `0xFF` （十进制 `255` ），用于标记压缩列表的末端。    |

### 压缩列表节点的构成

每个压缩列表节点都由 `previous_entry_length` 、 `encoding` 、 `content` 三个部分组成， 如图 7-4 所示。

![image-20230419190959490](redis.assets/image-20230419190959490.png)

* `previous_entry_length` 属性以字节为单位， 记录了压缩列表中前一个节点的长度。

  - 如果前一节点的长度小于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `1` 字节： 前一节点的长度就保存在这一个字节里面。

  - 如果前一节点的长度大于等于 `254` 字节， 那么 `previous_entry_length` 属性的长度为 `5` 字节：

* `encoding` 属性记录了节点的 `content` 属性所保存数据的类型以及长度

* `content` 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 `encoding` 属性决定

### 压缩列表的连锁更新

每个节点的 `previous_entry_length` 属性都记录了前一个节点的长度

所以添加或删除一个节点就会可能导致下一个节点长度也改变，进而下下一个节点也可能修改，依次类推就有可能导致压缩列表的连锁更新

### 重点回顾

- 压缩列表是一种为节约内存而开发的顺序型数据结构。
- 压缩列表被用作列表键和哈希键的底层实现之一。
- 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
- 添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。

## 对象

Redis基于上面数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。

通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。

### 对象类型及编码

Redis 中的每个对象都由一个 `redisObject` 结构表示

```c
typedef struct redisObject {

    // 类型，记录了对象的类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 指向底层实现数据结构的指针
    void *ptr;

    /*对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。*/
    
    // ...

} robj;
```

### 字符串对象

如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 `39` 字节， 那么字符串对象将使用 `embstr` 编码的方式来保存这个字符串值。

这种编码和 `raw` 编码一样， 都使用 `redisObject` 结构和 `sdshdr` 结构来表示字符串对象， 但 `raw` 编码会调用两次内存分配函数来分别创建 `redisObject` 结构和 `sdshdr` 结构， 而 `embstr` 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 `redisObject` 和 `sdshdr` 两个结构， 如图 8-3 所示。

![image-20230419191012294](redis.assets/image-20230419191012294.png)

`embstr` 编码的字符串对象在执行命令时， 产生的效果和 `raw` 编码的字符串对象执行命令时产生的效果是相同的， 但使用 `embstr` 编码的字符串对象来保存短字符串值有以下好处：

1. `embstr` 编码将创建字符串对象所需的内存分配次数从 `raw` 编码的两次降低为一次。
2. 释放 `embstr` 编码的字符串对象只需要调用一次内存释放函数， 而释放 `raw` 编码的字符串对象需要调用两次内存释放函数。
3. 因为 `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 `raw` 编码的字符串对象能够更好地利用缓存带来的优势。

`long double` 类型表示的浮点数在 Redis 中也是作为字符串值来保存的

#### 编码转换

* 对于 `int` 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 `int` 变为 `raw` 

* 因为 Redis 没有为 `embstr` 编码的字符串对象编写任何相应的修改程序 （只有 `int` 编码的字符串对象和 `raw` 编码的字符串对象有这些程序）， 所以 `embstr` 编码的字符串对象实际上是只读的： 当我们对 `embstr` 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 `embstr` 转换成 `raw` ， 然后再执行修改命令； 因为这个原因， `embstr` 编码的字符串对象在执行修改命令之后， 总会变成一个 `raw` 编码的字符串对象。

### 列表对象

列表对象的编码可以是 `ziplist` 或者 `linkedlist` 。

#### 编码转换

当列表对象可以同时满足以下两个条件时， 列表对象使用 `ziplist` 编码：

1. 列表对象保存的所有字符串元素的长度都小于 `64` 字节；
2. 列表对象保存的元素数量小于 `512` 个；

不能满足这两个条件的列表对象需要使用 `linkedlist` 编码。

### 哈希对象

哈希对象的编码可以是 `ziplist` 或者 `hashtable` 。

`ziplist` 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：

- 保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

`hashtable` 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：

- 字典的每个键都是一个字符串对象， 对象中保存了键值对的键；
- 字典的每个值都是一个字符串对象， 对象中保存了键值对的值。

#### 编码转换

当哈希对象可以同时满足以下两个条件时， 哈希对象使用 `ziplist` 编码：

1. 哈希对象保存的所有键值对的键和值的字符串长度都小于 `64` 字节；
2. 哈希对象保存的键值对数量小于 `512` 个；

不能满足这两个条件的哈希对象需要使用 `hashtable` 编码。

### 集合对象

集合对象的编码可以是 `intset` 或者 `hashtable` 。

`intset` 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。

`hashtable` 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 `NULL` 。

#### 编码转换

当集合对象可以同时满足以下两个条件时， 对象使用 `intset` 编码：

1. 集合对象保存的所有元素都是整数值；
2. 集合对象保存的元素数量不超过 `512` 个；

### 有序集合对象

有序集合的编码可以是 `ziplist` 或者 `skiplist` 。

`ziplist` 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。

压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。

`skiplist` 编码的有序集合对象使用 `zset` 结构作为底层实现， 一个 `zset` 结构同时包含一个字典和一个跳跃表：

```c
typedef struct zset {

    zskiplist *zsl;

    dict *dict;

} zset;
```

有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 `double` 类型的浮点数。 值得一提的是， 虽然 `zset` 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。

#### 编码转换

当有序集合对象可以同时满足以下两个条件时， 对象使用 `ziplist` 编码：

1. 有序集合保存的元素数量小于 `128` 个；
2. 有序集合保存的所有元素成员的长度都小于 `64` 字节；

不能满足以上两个条件的有序集合对象将使用 `skiplist` 编码。

### 类型检查与命令多态

#### 类型检查

为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。

#### 命令多态

Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。

### 内存回收

 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。

```c
typedef struct redisObject {

    // ...

    // 引用计数
    int refcount;

    // ...

} robj;
```

对象的引用计数信息会随着对象的使用状态而不断变化：

- 在创建一个新对象时， 引用计数的值会被初始化为 `1` ；
- 当对象被一个新程序使用时， 它的引用计数值会被增一；
- 当对象不再被一个程序使用时， 它的引用计数值会被减一；
- 当对象的引用计数值变为 `0` 时， 对象所占用的内存会被释放。

### 对象共享

除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。

在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：

* 将数据库键的值指针指向一个现有的值对象；

* 将被共享的值对象的引用计数增一。

目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0`到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。

#### 为什么 Redis 不共享包含字符串的对象？

当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：

- 如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 ![O(1)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a2227eb.png) ；
- 如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 ![O(N)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a314bb1.png) ；
- 如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 ![O(N^2)](https://atts.w3cschool.cn/attachments/image/cimg/2015-09-13_55f521a3ee960.png) 。

因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。

### 对象空转时长

`redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间：

```c
typedef struct redisObject {

    // 对象最后一次被命令程序访问的时间
    unsigned lru:22;

    // ...

} robj;
```

OBJECT IDLETIME 命令（空转时长）的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 `lru` 属性。

 ### 重点回顾

- Redis 数据库中的每个键值对的键和值都是一个对象。
- Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。
- Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。
- Redis 会共享值为 `0` 到 `9999` 的字符串对象。
- 对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。

# 单机数据库的实现

## 数据库

### 服务器中的数据库

Redis 是一个键值对（key-value pair）数据库服务器， 服务器中的每个数据库都由一个 `redis.h/redisDb` 结构表示， 其中， `redisDb` 结构的`dict` 字典保存了数据库中的所有键值对。

```c
struct redisServer{
	//..
    
    //一个数组，保存着服务器中的所有数据库
    redisDb *db;
    
    //服务器中的数据库的数量
    int dbnum;
    //..
};
```

```c
typedef struct redisDb {

    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;

    // ...

} redisDb;
```

### 设置键的过期时间

实际上expire,pexpire,expireat三个命令都是使用PEXPIREAT命令实现的

### 保存过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间，称之为过期字典：

* 过期字典的键是一个指针，这个指针指向键空间中的某个键对象
* 过期字典的只是一个long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间，是一个毫秒精度的UNIX时间戳

```c
typedef struct redisDb{
    //..
    
    //过期字典
    dict *expires;
    
    //..
}redisDb;
```

实际上过期字典的键空间的键和数据库键空间的键都指向同一个对象。

### 过期键的判定

通过过期字典，程序可以通过以下步骤检查一个给定的键是否过期：

	* 检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间
	* 检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则，未过期。

### 过期键删除策略

* 定时删除：设置键的过期时间的同时创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

  `定期删除对内存最友好`

  `但是在过期键比较多的情况下，删除过期键会占用相当一部分CPU时间`

* 惰性删除：每次从键空间获取键时，都检查取得的键是否过期，如果过期就删除该键，没有过期，返回改键

  `对CPU时间最友好`

  `如果一个键已经过期，而这个键仍然保留在数据库中，对内存不友好`

* 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。

  从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷:

  - 定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。
  - 惰性删除浪费太多内存，有内存泄漏的危险。

  定期删除策略是前两种策略的一种整合和折中:

  - 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的
    时长和频率来减少删除操作对CPU时间的影响。
  - 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的
    内存浪费。

  定期删除策略的难点是确定删除操作执行的时长和频率:

  - 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时
    删除策略，以至于将CPU时间过多地消耗在删除过期键上面。
  - 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策
    略一样，出现浪费内存的情况。

  因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。

Redis服务器实际上使用的是惰性删除和定期删除两种策略

#### 定期删除策略的实现



```python
#默认每次检查的数据库数量
DEFAULT_DB_NUMBERS = 16

#默认每个数据库检查的键数量
DEFAULT KEY NUMBERS = 20

#全局变量，记录检查进度
current_db = 0

def activeExpireCycle():
    #初始化要检查的数据库数量
    #如果服务器的数据库数量比DEFAULT_DB_NUMBERS 要小
    #那么以服务器的数据库数量为准

    if server .dbnum <DEFAULT_DB_NUMBERS:
    	db numbers = server.dbnum
    else:
    	db_numbers =DEFAULT_DB_NUMBERS
        
    #遍历各个数据库
    for i in range (db _numbers) :
        #如果current_db 的值等于服务器的数据库数量
        #这表示检查程序已经遍历了服务器的所有数据库一次
        #将current_db重置为0，开始新的一轮遍历

        if current_ db== server.dbnum:
    		current db = 0
        #获取当前要处理的数据库
        redisDb =server.db [current_db]
        
        #将数据库索引增1，指向下一个要处理的数据库
        current_db +=1
        
        #检查数据库键
        for j in range (DEFAULT_KEY__NUMBERS) :

        #如果数据库中没有一个键带有过期时间，那么跳过这个数据库
        if redisDb.expires.size ()== 0: break
            
        
        #随机获取一个带有过期时间的键
        key_with_ttl = redisDb.expires.get_random_key ()
        
        #检查键是否过期，如果过期就删除它
        if is_expired (key_with_ttl) :
        	delete_key (key_with_ttl)
            
        #已达到时间上限,停止处理
        if reach_time_limit() : return

```

* 函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
* 全局变量current_db 会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpirecycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。
* 随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。

### 重点回顾

- Redis 服务器的所有数据库都保存在 `redisServer.db` 数组中， 而数据库的数量则由 `redisServer.dbnum` 属性保存。
- 客户端通过修改目标数据库指针， 让它指向 `redisServer.db` 数组中的不同元素来切换不同的数据库。
- 数据库主要由 `dict` 和 `expires` 两个字典构成， 其中 `dict` 字典负责保存键值对， 而 `expires` 字典则负责保存键的过期时间。
- 因为数据库由字典构成， 所以对数据库的操作都是建立在字典操作之上的。
- 数据库的键总是一个字符串对象， 而值则可以是任意一种 Redis 对象类型， 包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象， 分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
- `expires` 字典的键指向数据库中的某个键， 而值则记录了数据库键的过期时间， 过期时间是一个以毫秒为单位的 UNIX 时间戳。
- Redis 使用惰性删除和定期删除两种策略来删除过期的键： 惰性删除策略只在碰到过期键时才进行删除操作， 定期删除策略则每隔一段时间， 主动查找并删除过期键。
- 执行 SAVE 命令或者 BGSAVE 命令所产生的新 RDB 文件不会包含已经过期的键。
- 执行 BGREWRITEAOF 命令所产生的重写 AOF 文件不会包含已经过期的键。
- 当一个过期键被删除之后， 服务器会追加一条 DEL 命令到现有 AOF 文件的末尾， 显式地删除过期键。
- 当主服务器删除一个过期键之后， 它会向所有从服务器发送一条 DEL 命令， 显式地删除过期键。
- 从服务器即使发现过期键， 也不会自作主张地删除它， 而是等待主节点发来 DEL 命令， 这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。
- 当 Redis 命令对数据库进行修改之后， 服务器会根据配置， 向客户端发送数据库通知。

## RDB持久化

因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。

为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。

RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中

### RDB文件的创建与载入

有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞明间，服务器不能处理任何命令请求。

RDB文件的**载入**工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在.它就会自动载人RDB文件。

另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以:

* 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
* 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

服务器在载人RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

### 自动间隔性保存

可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器会执行BGSAVE命令。

### RDB文件结构

![image-20230419191032659](redis.assets/image-20230419191032659.png)

 `REDIS` 部分， 这个部分的长度为 `5` 字节， 保存着 `"REDIS"` 五个字符。 通过这五个字符， 程序可以在载入文件时， 快速检查所载入的文件是否 RDB 文件。

`db_version` 长度为 `4` 字节， 它的值是一个字符串表示的整数， 这个整数记录了 RDB 文件的版本号， 比如 `"0006"` 就代表 RDB 文件的版本为第六版。

`databases` 部分包含着零个或任意多个数据库， 以及各个数据库中的键值对数据：

- 如果服务器的数据库状态为空（所有数据库都是空的）， 那么这个部分也为空， 长度为 `0` 字节。
- 如果服务器的数据库状态为非空（有至少一个数据库非空）， 那么这个部分也为非空， 根据数据库所保存键值对的数量、类型和内容不同， 这个部分的长度也会有所不同。

`EOF` 常量的长度为 `1` 字节， 这个常量标志着 RDB 文件正文内容的结束， 当读入程序遇到这个值的时候， 它知道所有数据库的所有键值对都已经载入完毕了

`check_sum` 是一个 `8` 字节长的无符号整数， 保存着一个校验和， 这个校验和是程序通过对 `REDIS` 、 `db_version` 、 `databases` 、 `EOF` 四个部分的内容进行计算得出的。 服务器在载入 RDB 文件时， 会将载入数据所计算出的校验和与 `check_sum` 所记录的校验和进行对比， 以此来检查 RDB 文件是否有出错或者损坏的情况出现。

#### databases部分

![image-20230419191043435](redis.assets/image-20230419191043435.png)

每个非空数据库在 RDB 文件中都可以保存为 `SELECTDB` 、 `db_number` 、 `key_value_pairs` 三个部分， 如图 IMAGE_DATABASE_STRUCT_OF_RDB 所示

![image-20230419191052559](redis.assets/image-20230419191052559.png)

`SELECTDB` 常量的长度为 `1` 字节， 当读入程序遇到这个值的时候， 它知道接下来要读入的将是一个数据库号码。

`db_number` 保存着一个数据库号码， 根据号码的大小不同， 这个部分的长度可以是 `1` 字节、 `2` 字节或者 `5` 字节。 当程序读入 `db_number` 部分之后， 服务器会调用 SELECT 命令， 根据读入的数据库号码进行数据库切换， 使得之后读入的键值对可以载入到正确的数据库中。

`key_value_pairs` 部分保存了数据库中的所有键值对数据， 如果键值对带有过期时间， 那么过期时间也会和键值对保存在一起。 根据键值对的数量、类型、内容、以及是否有过期时间等条件的不同， `key_value_pairs` 部分的长度也会有所不同。

##### key_value_pairs部分

`key_value_pairs` 部分都保存了一个或以上数量的键值对， 如果键值对带有过期时间的话， 那么键值对的过期时间也会被保存在内。

不带过期时间的键值对在 RDB 文件中对由 `TYPE` 、 `key` 、 `value` 三部分组成， 如图 IMAGE_KEY_WITHOUT_EXPIRE_TIME 所示。

![image-20230419191059855](redis.assets/image-20230419191059855.png)

`TYPE` 记录了 `value` 的类型， 长度为 `1` 字节，当服务器读入 RDB 文件中的键值对数据时， 程序会根据 `TYPE` 的值来决定如何读入和解释 `value` 的数据。

`key` 和 `value` 分别保存了键值对的键对象和值对象：

- 其中 `key` 总是一个字符串对象， 它的编码方式和 `REDIS_RDB_TYPE_STRING` 类型的 `value` 一样。 根据内容长度的不同， `key` 的长度也会有所不同。
- 根据 `TYPE` 类型的不同， 以及保存内容长度的不同， 保存 `value` 的结构和长度也会有所不同

带有过期时间的键值对在 RDB 文件中的结构如图 `IMAGE_KEY_WITH_EXPIRE_TIME` 所示。

![image-20230419191109279](redis.assets/image-20230419191109279.png)

- `EXPIRETIME_MS` 常量的长度为 `1` 字节， 它告知读入程序， 接下来要读入的将是一个以毫秒为单位的过期时间。
- `ms` 是一个 `8` 字节长的带符号整数， 记录着一个以毫秒为单位的 UNIX 时间戳， 这个时间戳就是键值对的过期时间。

value的编码

* 字符串对象

  字符串对象的编码可以是 `REDIS_ENCODING_INT` 或者`REDIS_ENCODING_RAW` 。

  如果字符串对象的编码为 `REDIS_ENCODING_INT` ， 那么说明对象中保存的是长度不超过 `32` 位的整数。

  如果字符串对象的编码为 `REDIS_ENCODING_RAW` ， 那么说明对象所保存的是一个字符串值， 根据字符串长度的不同， 有压缩和不压缩两种方法来保存这个字符串：

  - 如果字符串的长度小于等于 `20` 字节， 那么这个字符串会直接被原样保存。
  - 如果字符串的长度大于 `20` 字节， 那么这个字符串会被压缩之后再保存。

  对于没有被压缩的字符串， RDB 程序会以图 IMAGE_NON_COMPRESS_STRING 所示的结构来保存该字符串。

  ![image-20230419191117675](redis.assets/image-20230419191117675.png)

  其中， `string` 部分保存了字符串值本身，而 `len` 保存了字符串值的长度。

  对于压缩后的字符串， RDB 程序会以图 IMAGE_COMPRESSED_STRING 所示的结构来保存该字符串。

  ![image-20230419191127291](redis.assets/image-20230419191127291.png)

  其中， `REDIS_RDB_ENC_LZF` 常量标志着字符串已经被 LZF 算法压缩过了， 读入程序在碰到这个常量时， 会根据之后的 `compressed_len` 、 `origin_len` 和 `compressed_string` 三部分， 对字符串进行解压缩： 其中 `compressed_len` 记录的是字符串被压缩之后的长度， 而 `origin_len` 记录的是字符串原来的长度， `compressed_string` 记录的则是被压缩之后的字符串。

* 列表对象

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_LIST` ， 那么 `value` 保存的就是一个 `REDIS_ENCODING_LINKEDLIST` 编码的列表对象， RDB 文件保存这种对象的结构如图 IMAGE_LINKEDLIST_ENCODING_LIST 所示。

  ![image-20230419191138789](redis.assets/image-20230419191138789.png)

* 集合对象

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_SET` ， 那么 `value` 保存的就是一个 `REDIS_ENCODING_HT` 编码的集合对象， RDB 文件保存这种对象的结构如图 IMAGE_HT_ENCODING_SET 所示。

  ![image-20230419191146159](redis.assets/image-20230419191146159.png)

* 哈希表对象

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_HASH` ， 那么 `value` 保存的就是一个 `REDIS_ENCODING_HT` 编码的集合对象， RDB 文件保存这种对象的结构如图 IMAGE_HT_HASH 所示：

  - `hash_size` 记录了哈希表的大小， 也即是这个哈希表保存了多少键值对， 读入程序可以通过这个大小知道自己应该读入多少个键值对。
  - 以 `key_value_pair` 开头的部分代表哈希表中的键值对， 键值对的键和值都是字符串对象， 所以程序会以处理字符串对象的方式来保存和读入键值对。

  ![image-20230419191154715](redis.assets/image-20230419191154715.png)

* 有序集合对象

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_ZSET` ， 那么 `value` 保存的就是一个 `REDIS_ENCODING_SKIPLIST` 编码的有序集合对象， RDB 文件保存这种对象的结构如图 IMAGE_SKIPLIST_ZSET 所示。

  ![image-20230419191201586](redis.assets/image-20230419191201586.png)

* INTSET 编码的集合

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_SET_INTSET` ， 那么 `value` 保存的就是一个整数集合对象， RDB 文件保存这种对象的方法是， 先将整数集合转换为字符串对象， 然后将这个字符串对象保存到 RDB 文件里面。

  如果程序在读入 RDB 文件的过程中， 碰到由整数集合对象转换成的字符串对象， 那么程序会根据 `TYPE` 值的指示， 先读入字符串对象， 再将这个字符串对象转换成原来的整数集合对象。

* ZIPLIST 编码的列表、哈希表或者有序集合

  如果 `TYPE` 的值为 `REDIS_RDB_TYPE_LIST_ZIPLIST` 、 `REDIS_RDB_TYPE_HASH_ZIPLIST` 或者 `REDIS_RDB_TYPE_ZSET_ZIPLIST` ， 那么 `value` 保存的就是一个压缩列表对象， RDB 文件保存这种对象的方法是：

   	1. 将压缩列表转换成一个字符串对象。

  ​	 2.将转换所得的字符串对象保存到 RDB 文件。

  如果程序在读入 RDB 文件的过程中， 碰到由压缩列表对象转换成的字符串对象， 那么程序会根据 `TYPE` 值的指示， 执行以下操作：

​             1.  读入字符串对象，并将它转换成原来的压缩列表对象。

​			2.根据 `TYPE` 的值，设置压缩列表对象的类型： 如果 `TYPE` 的值为 `REDIS_RDB_TYPE_LIST_ZIPLIST` ， 那么压缩列表对象的类型为列表； 如果`TYPE` 的值   

​             为 `REDIS_RDB_TYPE_HASH_ZIPLIST` ， 那么压缩列表对象的类型为哈希表； 如果 `TYPE` 的值为 `REDIS_RDB_TYPE_ZSET_ZIPLIST` ， 那么压缩列表对象			的类型为有序集合。