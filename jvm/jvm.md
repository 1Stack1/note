# jvm的组成

## PC

> 什么是程序计数器

线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

> 程序计数器作用

* 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。

* 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。



## 堆

> 详细介绍一下堆

线程共享的区域：主要用来保存对象实例，数组等，内存不够则抛出OutOfMemoryError异常。

组成：年轻代+老年代

* 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区

* 老年代主要保存生命周期长的对象，一般是一些老的对象

lJdk1.7和1.8的区别

* 1.7中有有一个永久代，存储的是类信息、静态变量、常量、编译后的代码

* 1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出

![Java 运行时数据区域（JDK1.7）](jvm.assets/java-runtime-data-areas-jdk1.7.png)

![Java 运行时数据区域（JDK1.8 ）](jvm.assets/java-runtime-data-areas-jdk1.8.png)

> JDK8的JVM为什么取消了堆中的永久代 / 方法区

JDK 8取消了永久代主要是为了解决永久代的一些问题。永久代是一种特殊的堆区域，用于存储类信息、方法信息、常量池等数据。但是永久代容易导致内存溢出，而且垃圾回收效率低下，特别是在大量使用反射、动态代理等技术的情况下。此外，永久代的大小是固定的，无法动态调整，这也会导致一些问题。

为了解决这些问题，JDK 8引入了元空间（Metaspace）来代替永久代。元空间是存储在本地内存中的一部分。本地内存是由操作系统分配和管理的，它的大小不受Java虚拟机堆大小的限制，因此可以更好地支持动态调整元空间大小的需求。同时，由于本地内存不是Java虚拟机的堆内存，所以可以避免一些与堆内存相关的问题，例如Java虚拟机堆内存溢出等问题。

> JDK 1.7 为什么要将字符串常量池从方法区移动到堆中？

主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

## 虚拟机栈

> 介绍一下虚拟机栈

* 每个线程运行时所需要的内存，称为虚拟机栈

* 每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存

* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

> 垃圾回收是否涉及栈内存？

垃圾回收主要指就是堆内存，而在栈中当栈帧弹栈以后，内存就会释放

> 栈内存分配越大越好吗？

默认的栈内存通常为1024k，栈帧过大会导致线程数变少

> 方法内的局部变量是否线程安全？

* 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的

* 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

> 有哪些栈内存溢出情况

* 栈帧过多导致栈内存溢出，典型问题：递归调用

* 栈帧过大导致栈内存溢出

> 堆栈的区别是什么？

* 栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。

* 栈内存是线程私有的，而堆内存是线程共有的。

* 两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。

  ​        栈空间不足：java.lang.StackOverFlowError。

​			堆空间不足：java.lang.OutOfMemoryError。

> 栈可能出现的错误

**`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。

**`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

## 方法区

> 能不能解释一下方法区？

* 方法区(Method Area)是各个线程共享的内存区域

* 主要存储类的信息、运行时常量池

* 虚拟机启动的时候创建，关闭虚拟机时释放

* 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

> 介绍一下常量池

可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。

![image-20230518215257658](jvm.assets/image-20230518215257658.png)

> 介绍一下运行时常量池

常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

> **方法区和永久代以及元空间是什么关系呢？** 

方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。



## 直接内存

> 你听过直接内存吗？

* 并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存

* 常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理

  NIO，引入了一种基于通道与缓存区的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

示例：

常规IO，多了一次缓冲区复制：

![image-20230518220309201](jvm.assets/image-20230518220309201.png)

NIO：

![image-20230518220319779](jvm.assets/image-20230518220319779.png)





# 对象

## 对象的创建

1.**类加载检查**，虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在**常量池**中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2.**分配内存**，在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

3.**初始化零值**，内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4.**设置对象头**，初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5。**执行 init 方法**，在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

> 内存分配的方式有？

指针碰撞： 

- 适用场合：堆内存规整（即没有内存碎片）的情况下。
- 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
- 使用该分配方式的 GC 收集器：Serial, ParNew

空闲列表： 

- 适用场合：堆内存不规整的情况下。
- 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
- 使用该分配方式的 GC 收集器：CMS

> 内存分配并发问题

- **CAS+失败重试**
- **TLAB：** 为**每一个线程**预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

## 对象内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

**Hotspot 虚拟机的对象头包括两部分信息**：

* 第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）
* 类型指针

> 什么是对齐填充？

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 对象的访问定位

 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

* 句柄

  如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![对象的访问定位-使用句柄](jvm.assets/access-location-of-object-handle.png)

* 直接指针----->HotSpot 主要采用的方法

  如果使用直接指针访问，reference 中存储的直接就是对象的地址。

![对象的访问定位-直接指针](https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png)

* 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
* 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

# Class文件

## Class文件结构

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

### 魔数

每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。

### 版本号

第 5 和第 6 位是**次版本号**，第 7 和第 8 位是**主版本号**。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。

### 常量池

紧接着主次版本号之后的是常量池。

常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 `public` 或者 `abstract` 类型，如果是类的话是否声明为 `final` 等等。

### 当前类、父类、接口索引集合

ava 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 Java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。

接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 `implements` (如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

### 字段表，方法表，属性表集合

# 加载器

## 介绍

> 什么是类加载器

JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。

> 类加载器有哪些

![image-20230518220708554](jvm.assets/image-20230518220708554.png)

## 类加载器加载过程

类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）

### 加载

* 通过类的全名，获取类的二进制数据流。

* 解析类的二进制数据流到方法区内的数据结构（Java类模型） 

* 创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口

![image-20230518231128900](jvm.assets/image-20230518231128900.png)

### 验证

验证类是否符合 JVM规范，安全性检查

![image-20230518231346662](jvm.assets/image-20230518231346662.png)

### 准备



**为类变量分配内存并设置类变量初始值**

![image-20230518231652324](jvm.assets/image-20230518231652324.png)

### 解析

**把类中的符号引用转换为直接引用**，比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。

从

![image-20230518232126886](jvm.assets/image-20230518232126886.png)

到

![image-20230518232211678](jvm.assets/image-20230518232211678.png)

### 初始化

**对类的静态变量，静态代码块执行初始化操作**

* 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

* 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

* 当只使用父类的静态变量(或从子类获取父类的静态变量)就会只初始化父类的静态代码块，而不会初始化子类的静态代码块。

### 使用

JVM 开始从入口方法开始执行用户的程序代码

* 调用静态类成员信息（比如：静态字段、静态方法）

* 使用new关键字为其创建对象实例

### 总结

* 加载:查找和导入class文件

* 验证:保证加载类的准确性

* 准备:为类变量分配内存并设置类变量初始值

*  解析:把类中的符号引用转换为直接引用

* 初始化:对类的静态变量，静态代码块执行初始化操作

* 使用:JVM 开始从入口方法开始执行用户的程序代码

* 卸载:当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。

## 双亲委派机制

> 什么是双亲委派模型？

加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类

> JVM为什么采用双亲委派机制？

* 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。

* 为了安全，保证类库API不会被修改

# 垃圾回收

## 垃圾对象判断方法

> 对象什么时候可以被垃圾器回收

如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

> 定位垃圾的方式

* 引用计数法

  一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。

  当对象间出现了循环引用的话，则引用计数法可能就会失效。

* 可达性分析算法

  现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。

  扫描堆中的对象，看是否能够沿着 GC Root 对象 为起点的引用链找到该对象，找不到，表示可以回收。

> 哪些对象可以作为 GC Root 

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象

> 如何判断一个常量是废弃常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

> 如何判断一个类是否可以被回收？

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

## 垃圾回收算法

> JVM 垃圾回收算法有哪些？

* 标记清除算法：垃圾回收分为2个阶段，分别是标记和清除,效率高,有磁盘碎片，内存不连续------一般不使用

* 标记整理算法：标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低------一般用于老年代

* 复制算法：将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低--------一般用于年轻代

### 标记清除算法

![image-20230519124100778](jvm.assets/image-20230519124100778.png)

### 标记整理算法

![image-20230519124123636](jvm.assets/image-20230519124123636.png)

### 整理算法

![image-20230519124141657](jvm.assets/image-20230519124141657.png)

## 分代垃圾回收

> 说一下JVM中的分代回收

根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

> 堆的区域划分

* 堆被分为了两份：新生代和老年代【1：2】

* 对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor(分成from和to)【8：1：1】

> 对象回收分代回收过程

* 新创建的对象，都会先分配到eden区
* 当Eden内存不足，标记Eden与 from（现阶段没有）的存活对象
* 将存活对象采用复制算法复制到to中，复制完毕后，Eden和 from 内存都得到释放
* 经过一段时间后Eden的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区
* 当幸存区对象熬过几次回收（最多15次），晋升到老年代（当幸存区内存不足或大对象会提前晋升）

> 为什么大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

大对象直接进入老年代主要是为了避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率

>什么是分配担保机制

只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC

> 对象什么时候进入老年代

虚拟机给每个对象一个对象年龄（Age）计数器，大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> MinorGC、 Mixed GC 、 FullGC的区别是什么？

* 部分收集
  * MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）--------->STW（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成。
  * MajorGC【old GC】只对老年代收集。
  * Mixed GC 【混合GC】新生代 + 老年代部分区域的垃圾回收，G1 收集器特有
* FullGC【整堆GC】： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免

> 对象可以被回收，就代表一定会被回收吗？

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；

可达性分析法中不可达的对象被第一次标记并且进行一次筛选，(筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行,*finalize方法在JDK9已被去掉*)。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。



## 垃圾回收器

> 在jvm中，实现了多种垃圾收集器，主要包括

* 串行垃圾收集器：Serial(色vu) GC、Serial Old GC

* 并行垃圾收集器：Parallel(破ruiv) Old GC、ParNew GC

* CMS（并发）垃圾收集器：CMS GC，作用在老年代

* G1垃圾收集器，作用在新生代和老年代

### 串行垃圾回收器

![image-20230519130712659](jvm.assets/image-20230519130712659.png)

### 并行垃圾回收器

![image-20230519130737803](jvm.assets/image-20230519130737803.png)

### 并发垃圾回收器

![CMS 收集器](jvm.assets/cms-garbage-collector.png)

整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 从GC Roots直接关联对象开始遍历整个对象图的过程，可以和用户线程并发执行
- **重新标记：**所有用户线程暂停，修正并发标记期间，因用户线程继续运作而导致标记产生变动部分对象的标记记录，远比并发标记时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生**

> 什么是浮动垃圾？

在并发标记阶段本来可达的对象，由于用户线程的作用变得不可达了，即产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终导致这些新产生的垃圾对象没有被及时回收。

> 在重新标记阶段会修正由于用户线程运作而导致对象的标记产生变动的记录，那为什么还有浮动垃圾产生？ 

由于标记阶段是从 GC Roots开始标记可达对象，那么在并发标记阶段可能产生两种变动：

1）本来可达的对象，变得不可达了

2）本来不可达的对象，变得可达了

如果在并发标记阶段中，用户线程new了一个对象，而它在初始标记和并发标记中无法从GC Roots可达，如果没有重新标记阶段将这个对象标记为可达，那么在并发清除阶段被回收，这是严重的错误。

相比之下，浮动垃圾是可容忍的问题，由于从可达变为不可达的变化需要重新从GC Roots开始遍历，相当于再次完成初始标记和并发标记的工作，这样会造成增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS不能容忍的。

### G1垃圾回收器

* 应用于新生代和老年代，在JDK9之后默认使用G1

* 划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备

* 采用复制算法

* 响应时间与吞吐量兼顾

* 分成三个阶段：新生代回收(stw)、并发标记(重新标记stw)、混合收集

* 如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC

[G1垃圾回收器执行过程](G1垃圾回收器.pptx)

G1运行示意图

![G1 收集器](jvm.assets/g1-garbage-collector.png)

> G1优点

* **并行与并发**

* **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。

* **空间整合**：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。

* **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。



## 四种引用

> 强引用、软引用、弱引用、虚引用的区别?

* 强引用：只要所有 GC Roots 能找到，就不会被回收
* 软引用：需要配合SoftReference使用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
* 弱引用：需要配合WeakReference使用，不管内存是否足够，只要发生 GC，都会被回收。
* 虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用PhantomReference入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

# jvm实践

> JVM 调优的参数可以在哪里设置参数值

* war包部署在tomcat中设置

​    修改TOMCAT_HOME/bin/catalina.sh文件

* jar包部署在启动参数设置

​     java -Xms512m -Xmx1024m -jar xxxx.jar



## JVM 调优的参数

### 设置堆空间大小

设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。

![image-20230519170926738](jvm.assets/image-20230519170926738.png)

堆空间设置多少合适？

* 最大大小的默认值是物理内存的1/4，初始大小是物理内存的1/64

* 堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户线程

* 堆内存大肯定是好的，存在风险，假如发生了fullgc,它会扫描整个堆空间，暂停用户线程的时间长

* 设置参考推荐：尽量大，也要考察一下当前计算机其他程序的内存使用情况

### 设置虚拟机栈大小

虚拟机栈的设置：每个线程默认会开启1M的内存，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。

![image-20230519171032734](jvm.assets/image-20230519171032734.png)

### Eden区和两个Survivor区的大小比例

设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。

![image-20230519171117997](jvm.assets/image-20230519171117997.png)

### 年轻代晋升老年代阈值

![image-20230519171147620](jvm.assets/image-20230519171147620.png)

### 设置垃圾回收收集器

![image-20230519171223932](jvm.assets/image-20230519171223932.png)

## JVM 调优的工具

命令工具

* jps     进程状态信息

* jstack   查看java进程内线程的堆栈信息

* jmap   查看堆转信息

* jhat    堆转储快照分析工具

* jstat   JVM统计监测工具

可视化工具

* jconsole   用于对jvm的内存，线程，类 的监控

* VisualVM  能够监控线程，内存情况

## 内存泄漏排查

> java内存泄露的排查思路？

内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况

1、通过jmap或设置jvm参数(当项目刚启动就闪退只能使用参数方式)获取堆内存快照dump

2、通过工具， VisualVM去分析dump文件，VisualVM可以加载离线的dump文件

3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

4、找到对应的代码，通过阅读上下文的情况，进行修复即可

![image-20230519173039491](jvm.assets/image-20230519173039491.png)

![image-20230519173052273](jvm.assets/image-20230519173052273.png)

![image-20230519173107112](jvm.assets/image-20230519173107112.png)

## CPU飙升排查

1.使用top命令查看占用cpu的情况

2.通过top命令查看后，可以查看是哪一个进程占用cpu较高

3.使用ps命令查看进程中的线程信息

4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题